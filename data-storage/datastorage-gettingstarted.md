---
title: Getting Started
page_title: Getting Started
description: Getting Started
slug: datastorage-gettingstarted
tags: getting,started
published: True
position: 1
---

# Getting Started

The Telerik Data Storage ships with the installation of the Telerik UI for Windows Universal suite. This article will explain how to add the Data Storage reference to your application and then, how to use it to build data-oriented applications.

## Installing the Data Storage

To install the Telerik Data Storage, you have to [download the Telerik UI for Windows Universal installator]({%slug installationsteps%}).

## Referencing the Data Storage in Your Project

To add the Telerik Data Storage to an app, do the following:

1. Once the Data Storage SDK is installed, you can open a new or existing project, right-click the **References** folder and select **Add Reference** from the context menu.
1. In the References dialog select **Telerik Data Storage for Windows Universal** extension. Note that this will automatically add a reference to **Microsoft Visual C++ Runtime Package**. This SDK is needed because the Telerik Data Storage runs native C++ code.

## Using the Data Storage in C#/XAML projects

> To deploy an application successfully on any machine, you must select the right Solution Platform since the **Data Storage** component uses native code that is CPU architecture dependent and must be rebuilt for all architectures (x86, ARM, x64). To do this, you need to open the **Configuration Manager** dialog that is accessible from *Build\Configuration Manager...* menu item of Visual Studio 2012/2013. You must ensure that all projects in your solution use the same platform. When you publish your application in the Windows Store, you need to build and deploy .appx packages for all platform configurations. This is the common requirement for all Windows Store applications that use native components. For more information, read this article on MSDN: [Creating an app package](http://msdn.microsoft.com/en-us/library/windows/apps/hh975357.aspx).

The initial steps to use the Data Storage component are as follows:

1. Create an object of type **[Context]({%slug datastorage-contextobject%})** – this way a database file will be created if it doesn't exist, or will be opened for further CRUD operations. The context object keeps the internal state of data schema and data that should be persisted (deleted, inserted or changed). During the construction of this object you can specify the name and location of the database using the enumeration.

>To create and use the **Context** object include the following namespace: **Telerik.Storage.Extensions**.
	
	public enum DatabaseLocation { Local = 0, Roaming, Temporary, Fullpath}
	var context = new Context("CarsDB", DatabaseLocation.Roaming);

1. Define [entity classes]({%slug datastorage-entities-overview%}) that will represent the objects in the database. For the example we will create a **Car** class and a **CarOwner** class.
	
		public class CarOwners
		{
			[Key]
			public long OwnerID{ get; set; }
			public string Name { get; set; }
			public int Age { get; set; }
			public bool Alive { get; set; }
			public DateTime DateBorn { get; set; }
		}
		
		public class Cars
		{
			[Key]
			[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
			public long CarID { get; set; }
			public string Model { get; set; }
			public DateTime YearOfModel { get; set; }
			public string RegistrationNumber { get; set; }
			public long OwnerFK { get; set; }
		}

1. Call any member of the context object for [CRUD operations]({%slug datastorage-crudoperationsoverview%}). Here we will insert some entries in the database:
	
		context.Insert<CarOwners>(new CarOwners() { OwnerID = 1, Name="Paul Grohe", Age=33,Alive = true, DateBorn=new DateTime(1980,7,23), });
		context.Insert<CarOwners>(new CarOwners() { OwnerID = 2, Name = "Alex Claude", Age = 33, Alive = true, DateBorn = new DateTime(1980, 7, 23), });
		context.Insert<CarOwners>(new CarOwners() { OwnerID = 3, Name = "Stephen Dred", Age = 33, Alive = true, DateBorn = new DateTime(1980, 7, 23), });

		//Note: CarID primary key field is autogenerated incremental
		context.Insert<Cars>(new Cars() { Model = "BMW", RegistrationNumber = "ZD123DF", YearOfModel = new DateTime(2010, 1, 1), OwnerFK = 1 });
		context.Insert<Cars>(new Cars() { Model = "Lancia", RegistrationNumber = "WD4313FF", YearOfModel = new DateTime(2008, 1, 1), OwnerFK = 2 });
		context.Insert<Cars>(new Cars() { Model = "Audi", RegistrationNumber = "KD2233DD", YearOfModel = new DateTime(2011, 1, 1), OwnerFK = 3 });
		context.Insert<Cars>(new Cars() { Model = "Mercedes", RegistrationNumber = "PF123ML", YearOfModel = new DateTime(2012, 1, 1), OwnerFK = 1 });
		context.Insert<Cars>(new Cars() { Model = "Toyota", RegistrationNumber = "JD149KL", YearOfModel = new DateTime(2009, 1, 1), OwnerFK = 2 });

1. Save (persist) changes in a database via the context object in order to persist the changed states in context to the database – this will update the records and the table schema.
	
		context.SaveChanges();

1. Close database before exit application or creation of new Context object.
	
		context.CloseDatabase();

# See Also

 * [Rad Controld for Windows Universal Installation Steps]({%slug installationsteps%})
 * [Context Class]({%slug datastorage-contextobject%})
 * [Entities Overview]({%slug datastorage-entities-overview%})
 * [CRUD Operations Overview]({%slug datastorage-crudoperationsoverview%})
 * [Good Practices]({%slug datastorage-goodpractices%})